diff --git a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/CryptoMapper.java b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/CryptoMapper.java
index 05e7c30..99f7afc 100755
--- a/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/CryptoMapper.java
+++ b/wicket-core/src/main/java/org/apache/wicket/core/request/mapper/CryptoMapper.java
@@ -16,6 +16,7 @@
  */
 package org.apache.wicket.core.request.mapper;
 
+import java.util.Iterator;
 import java.util.List;
 
 import org.apache.wicket.Application;
@@ -25,25 +26,48 @@ import org.apache.wicket.request.IRequestMapper;
 import org.apache.wicket.request.Request;
 import org.apache.wicket.request.Url;
 import org.apache.wicket.request.mapper.IRequestMapperDelegate;
+import org.apache.wicket.request.mapper.info.PageComponentInfo;
 import org.apache.wicket.util.IProvider;
 import org.apache.wicket.util.crypt.ICrypt;
 import org.apache.wicket.util.crypt.ICryptFactory;
 import org.apache.wicket.util.lang.Args;
 import org.apache.wicket.util.string.Strings;
+
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 /**
- * Request mapper that encrypts urls generated by another mapper. The original URL (both segments
- * and parameters) is encrypted and is represented as URL segment. To be able to handle relative
- * URLs for images in .css file the same amount of URL segments that the original URL had are
- * appended to the encrypted URL. Each segment has a precise 5 character value, calculated using a
- * checksum. This helps in calculating the relative distance from the original URL. When a URL is
- * returned by the browser, we iterate through these checksummed placeholder URL segments. If the
- * segment matches the expected checksum, then the segment it deemed to be the corresponding segment
- * in the encrypted URL. If the segment does not match the expected checksum, then the segment is
- * deemed a plain text sibling of the corresponding segment in the encrypted URL, and all subsequent
+ * <p>
+ * A request mapper that encrypts URLs generated by another mapper. This mapper encrypts the segments
+ * and query parameters of URLs starting with {@code /wicket/}, and the just the {@link PageComponentInfo}
+ * parameter for mounted URLs.
+ * </p>
+ * 
+ * <p>
+ * This mapper can be mounted before or after mounting other pages, but will only encrypt URLs for
+ * pages mounted before the {@link CryptoMapper}. If required, multiple {@link CryptoMapper}s may be
+ * installed in an {@link Application}.
+ * </p>
+ * 
+ * <p>
+ * When encrypting URLs in the Wicket namespace (starting with {@code /wicket/}), the entire URL, including
+ * segments and parameters, is encrypted, with the encrypted form stored in the first segment of the encrypted URL.
+ * </p>
+ * 
+ * <p>
+ * To be able to handle relative URLs, like for image URLs in a CSS file, checksum segments are appended to the
+ * encrypted URL until the encrypted URL has the same number of segments as the original URL had.
+ * Each checksum segment has a precise 5 character value, calculated using a checksum. This helps in calculating
+ * the relative distance from the original URL. When a URL is returned by the browser, we iterate through these
+ * checksummed placeholder URL segments. If the segment matches the expected checksum, then the segment it deemed
+ * to be the corresponding segment in the original URL. If the segment does not match the expected checksum, then
+ * the segment is deemed a plain text sibling of the corresponding segment in the original URL, and all subsequent
  * segments are considered plain text children of the current segment.
+ * </p>
+ * 
+ * <p>
+ * When encrypting mounted URLs, we look for the {@link PageComponentInfo} parameter, and encrypt only that parameter.
+ * </p>
  * 
  * @author igor.vaynberg
  * @author Jesse Long
@@ -53,6 +77,11 @@ public class CryptoMapper implements IRequestMapperDelegate
 {
 	private static final Logger log = LoggerFactory.getLogger(CryptoMapper.class);
 
+	/**
+	 * Name of the parameter which contains encrypted page component info.
+	 */
+	private static final String ENCRYPTED_PAGE_COMPONENT_INFO_PARAMETER = "wicket";
+
 	private final IRequestMapper wrappedMapper;
 	private final IProvider<ICrypt> cryptProvider;
 
@@ -87,12 +116,34 @@ public class CryptoMapper implements IRequestMapperDelegate
 		this.cryptProvider = Args.notNull(cryptProvider, "cryptProvider");
 	}
 
+	/**
+	 * {@inheritDoc}
+	 * <p>
+	 * This implementation decrypts the URL and passes the decrypted URL to the wrapped mapper.
+	 * </p>
+	 * @param request
+	 *		The request for which to get a compatability score.
+	 * 
+	 * @return The compatability score.
+	 */
 	@Override
 	public int getCompatibilityScore(final Request request)
 	{
-		return wrappedMapper.getCompatibilityScore(request);
+		Url decryptedUrl = decryptUrl(request, request.getUrl());
+
+		if (decryptedUrl == null)
+		{
+			return 0;
+		}
+
+		Request decryptedRequest = request.cloneWithUrl(decryptedUrl);
+
+		return wrappedMapper.getCompatibilityScore(decryptedRequest);
 	}
 
+	/**
+	 * {@inheritDoc}
+	 */
 	@Override
 	public Url mapHandler(final IRequestHandler requestHandler)
 	{
@@ -112,6 +163,9 @@ public class CryptoMapper implements IRequestMapperDelegate
 		return encryptUrl(url);
 	}
 
+	/**
+	 * {@inheritDoc}
+	 */
 	@Override
 	public IRequestHandler mapRequest(final Request request)
 	{
@@ -119,7 +173,7 @@ public class CryptoMapper implements IRequestMapperDelegate
 
 		if (url == null)
 		{
-			return wrappedMapper.mapRequest(request);
+			return null;
 		}
 
 		Request decryptedRequest = request.cloneWithUrl(url);
@@ -152,18 +206,44 @@ public class CryptoMapper implements IRequestMapperDelegate
 		return wrappedMapper;
 	}
 
+	/**
+	 * Encrypts a URL. This method should return a new, encrypted instance of the URL. If the URL starts with {@code /wicket/},
+	 * the entire URL is encrypted.
+	 * 
+	 * @param url
+	 *		The URL to encrypt.
+	 * 
+	 * @return A new, encrypted version of the URL.
+	 */
 	protected Url encryptUrl(final Url url)
 	{
-		if (url.getSegments().isEmpty())
+		if (url.getSegments().size() > 0
+			&& url.getSegments().get(0).equals(Application.get().getMapperContext().getNamespace()))
 		{
-			return url;
+			return encryptEntireUrl(url);
 		}
+		else
+		{
+			return encryptRequestListenerParameter(url);
+		}
+	}
+
+	/**
+	 * Encrypts an entire URL, segments and query parameters.
+	 * 
+	 * @param url
+	 *		The URL to encrypt.
+	 * 
+	 * @return An encrypted form of the URL.
+	 */
+	protected Url encryptEntireUrl(final Url url)
+	{
 		String encryptedUrlString = getCrypt().encryptUrlSafe(url.toString());
 
 		Url encryptedUrl = new Url(url.getCharset());
 		encryptedUrl.getSegments().add(encryptedUrlString);
 
-		int numberOfSegments = url.getSegments().size();
+		int numberOfSegments = url.getSegments().size() - 1;
 		HashedSegmentGenerator generator = new HashedSegmentGenerator(encryptedUrlString);
 		for (int segNo = 0; segNo < numberOfSegments; segNo++)
 		{
@@ -172,86 +252,274 @@ public class CryptoMapper implements IRequestMapperDelegate
 		return encryptedUrl;
 	}
 
+	/**
+	 * Encrypts the {@link PageComponentInfo} query parameter in the URL, if any is found.
+	 * 
+	 * @param url
+	 *		The URL to encrypt.
+	 * 
+	 * @return An encrypted form of the URL.
+	 */
+	protected Url encryptRequestListenerParameter(final Url url)
+	{
+		Url encryptedUrl = new Url(url);
+
+		for (Iterator<Url.QueryParameter> it = encryptedUrl.getQueryParameters().iterator(); it.hasNext();)
+		{
+			Url.QueryParameter qp = it.next();
+
+			if (Strings.isEmpty(qp.getValue()) == true && Strings.isEmpty(qp.getName()) == false)
+			{
+				if (PageComponentInfo.parse(qp.getName()) != null)
+				{
+					it.remove();
+					String encryptedParameterValue = getCrypt().encryptUrlSafe(qp.getName());
+					Url.QueryParameter encryptedParameter
+						= new Url.QueryParameter(ENCRYPTED_PAGE_COMPONENT_INFO_PARAMETER, encryptedParameterValue);
+					encryptedUrl.getQueryParameters().add(0, encryptedParameter);
+					break;
+				}
+			}
+		}
+
+		return encryptedUrl;
+	}
+
+	/**
+	 * Decrypts a {@link Url}. This method should return {@code null} if the URL is not decryptable, or if the
+	 * URL should have been encrypted but was not. Returning {@code null} results in a 404 error.
+	 * 
+	 * @param request
+	 *		The {@link Request}.
+	 * @param encryptedUrl
+	 *		The encrypted {@link Url}.
+	 * 
+	 * @return Returns a decrypted {@link Url}.
+	 */
 	protected Url decryptUrl(final Request request, final Url encryptedUrl)
 	{
-		/*
-		 * If the encrypted URL has no segments it is the home page URL, and does not need
-		 * decrypting.
-		 */
-		if (encryptedUrl.getSegments().isEmpty())
+		Url url = decryptEntireUrl(request, encryptedUrl);
+
+		if (url == null)
 		{
-			return encryptedUrl;
+			if (encryptedUrl.getSegments().size() > 0
+				&& encryptedUrl.getSegments().get(0).equals(Application.get().getMapperContext().getNamespace()))
+			{
+				/*
+				 * This URL should have been encrypted, but was not. We should refuse to handle this, except when
+				 * there is more than one CryptoMapper installed, and the request was decrypted by some other
+				 * CryptoMapper.
+				 */
+				if (request.getOriginalUrl().getSegments().size() > 0
+					&& request.getOriginalUrl().getSegments().get(0).equals(Application.get().getMapperContext().getNamespace()))
+				{
+					return null;
+				}
+				else
+				{
+					return encryptedUrl;
+				}
+			}
 		}
 
-		List<String> encryptedSegments = encryptedUrl.getSegments();
+		if (url == null)
+		{
+			url = decryptRequestListenerParameter(request, encryptedUrl);
+		}
+
+		return url;
+	}
 
+	/**
+	 * Decrypts an entire URL, which was previously encrypted by {@link #encryptEntireUrl(org.apache.wicket.request.Url)}.
+	 * This method should return {@code null} if the URL is not decryptable.
+	 * 
+	 * @param request
+	 *		The request that was made.
+	 * @param encryptedUrl
+	 *		The encrypted URL.
+	 * 
+	 * @return A decrypted form of the URL, or {@code null} if the URL is not decryptable.
+	 */
+	protected Url decryptEntireUrl(final Request request, final Url encryptedUrl)
+	{
 		Url url = new Url(request.getCharset());
+
+		List<String> encryptedSegments = encryptedUrl.getSegments();
+
+		if (encryptedSegments.isEmpty())
+		{
+			return null;
+		}
+
+		/*
+		 * The first encrypted segment contains an encrypted version of the entire plain text url.
+		 */
+		String encryptedUrlString = encryptedSegments.get(0);
+		if (Strings.isEmpty(encryptedUrlString))
+		{
+			return null;
+		}
+
+		String decryptedUrl;
 		try
 		{
+			decryptedUrl = getCrypt().decryptUrlSafe(encryptedUrlString);
+		}
+		catch (Exception e)
+		{
+			log.error("Error decrypting URL", e);
+			return null;
+		}
+
+		if (decryptedUrl == null)
+		{
+			return null;
+		}
+
+		Url originalUrl = Url.parse(decryptedUrl, request.getCharset());
+
+		int originalNumberOfSegments = originalUrl.getSegments().size();
+		int encryptedNumberOfSegments = encryptedUrl.getSegments().size();
+
+		if (originalNumberOfSegments > 0)
+		{
 			/*
-			 * The first encrypted segment contains an encrypted version of the entire plain text
-			 * url.
+			 * This should always be true. Home page URLs are the only ones without
+			 * segments, and we dont encrypt those with this method.
+			 * 
+			 * We always add the first segment of the URL, because we encrypt a URL like:
+			 *	/path/to/something
+			 * to:
+			 *	/encrypted_full/hash/hash
+			 * 
+			 * Notice the consistent number of segments. If we applied the following relative URL:
+			 *	../../something
+			 * then the resultant URL would be:
+			 *	/something
+			 * 
+			 * Hence, the mere existence of the first, encrypted version of complete URL, segment
+			 * tells us that the first segment of the original URL is still to be used.
 			 */
-			String encryptedUrlString = encryptedSegments.get(0);
-			if (Strings.isEmpty(encryptedUrlString))
+			url.getSegments().add(originalUrl.getSegments().get(0));
+		}
+
+		HashedSegmentGenerator generator = new HashedSegmentGenerator(encryptedUrlString);
+		int segNo = 1;
+		for (; segNo < encryptedNumberOfSegments; segNo++)
+		{
+			if (segNo > originalNumberOfSegments)
 			{
-				return null;
+				break;
 			}
 
-			String decryptedUrl = getCrypt().decryptUrlSafe(encryptedUrlString);
-			if (decryptedUrl == null)
+			String next = generator.next();
+			String encryptedSegment = encryptedSegments.get(segNo);
+			if (!next.equals(encryptedSegment))
 			{
-				return null;
+				/*
+				 * This segment received from the browser is not the same as the expected segment generated
+				 * by the HashSegmentGenerator. Hence it, and all subsequent segments are considered plain
+				 * text siblings of the original encrypted url.
+				 */
+				break;
 			}
-			Url originalUrl = Url.parse(decryptedUrl, request.getCharset());
 
-			int originalNumberOfSegments = originalUrl.getSegments().size();
-			int encryptedNumberOfSegments = encryptedUrl.getSegments().size();
+			/*
+			 * This segments matches the expected checksum, so we add the corresponding segment from the
+			 * original URL.
+			 */
+			url.getSegments().add(originalUrl.getSegments().get(segNo));
+		}
+		/*
+		 * Add all remaining segments from the encrypted url as plain text segments.
+		 */
+		for (; segNo < encryptedNumberOfSegments; segNo++)
+		{
+			// modified or additional segment
+			url.getSegments().add(encryptedUrl.getSegments().get(segNo));
+		}
 
-			HashedSegmentGenerator generator = new HashedSegmentGenerator(encryptedUrlString);
-			int segNo = 1;
-			for (; segNo < encryptedNumberOfSegments; segNo++)
-			{
-				if (segNo > originalNumberOfSegments)
-				{
-					break;
-				}
+		url.getQueryParameters().addAll(originalUrl.getQueryParameters());
+		// WICKET-4923 additional parameters
+		url.getQueryParameters().addAll(encryptedUrl.getQueryParameters());
+
+		return url;
+	}
+
+	/**
+	 * Decrypts a URL which may contain an encrypted {@link PageComponentInfo} query parameter.
+	 * 
+	 * @param request
+	 *		The request that was made.
+	 * @param encryptedUrl
+	 *		The (potentially) encrypted URL.
+	 * 
+	 * @return A decrypted form of the URL.
+	 */
+	protected Url decryptRequestListenerParameter(final Request request, Url encryptedUrl)
+	{
+		Url url = new Url(encryptedUrl);
 
-				String next = generator.next();
-				String encryptedSegment = encryptedSegments.get(segNo);
-				if (!next.equals(encryptedSegment))
+		url.getQueryParameters().clear();
+
+		for (Url.QueryParameter qp : encryptedUrl.getQueryParameters())
+		{
+			if (Strings.isEmpty(qp.getValue()) && Strings.isEmpty(qp.getName()) == false)
+			{
+				if (PageComponentInfo.parse(qp.getName()) != null)
 				{
 					/*
-					 * This segment received from the browser is not the same as the expected
-					 * segment generated by the HashSegmentGenerator. Hence it, and all subsequent
-					 * segments are considered plain text siblings of the original encrypted url.
+					 * Plain text request listener parameter found. This should have been encrypted, so we
+					 * refuse to map the request unless the original URL did not include this parameter, which
+					 * case there are likely to be multiple cryptomappers installed.
 					 */
-					break;
+					if (request.getOriginalUrl().getQueryParameter(qp.getName()) == null)
+					{
+						url.getQueryParameters().add(qp);
+					}
+					else
+					{
+						return null;
+					}
 				}
+			}
+			else if (ENCRYPTED_PAGE_COMPONENT_INFO_PARAMETER.equals(qp.getName()))
+			{
+				String encryptedValue = qp.getValue();
 
-				/*
-				 * This segments matches the expected checksum, so we add the corresponding segment
-				 * from the original URL.
-				 */
-				url.getSegments().add(originalUrl.getSegments().get(segNo - 1));
+				if (Strings.isEmpty(encryptedValue))
+				{
+					url.getQueryParameters().add(qp);
+				}
+				else
+				{
+					String decryptedValue = null;
+
+					try
+					{
+						decryptedValue = getCrypt().decryptUrlSafe(encryptedValue);
+					}
+					catch (Exception e)
+					{
+						log.error("Error decrypting encrypted request listener query parameter", e);
+					}
+
+					if (Strings.isEmpty(decryptedValue))
+					{
+						url.getQueryParameters().add(qp);
+					}
+					else
+					{
+						Url.QueryParameter decryptedParamter = new Url.QueryParameter(decryptedValue, "");
+						url.getQueryParameters().add(0, decryptedParamter);
+					}
+				}
 			}
-			/*
-			 * Add all remaining segments from the encrypted url as plain text segments.
-			 */
-			for (; segNo < encryptedNumberOfSegments; segNo++)
+			else
 			{
-				// modified or additional segment
-				url.getSegments().add(encryptedUrl.getSegments().get(segNo));
+				url.getQueryParameters().add(qp);
 			}
-
-			url.getQueryParameters().addAll(originalUrl.getQueryParameters());
-			// WICKET-4923 additional parameters
-			url.getQueryParameters().addAll(encryptedUrl.getQueryParameters());
-		}
-		catch (Exception e)
-		{
-			log.error("Error decrypting URL", e);
-			url = null;
 		}
 
 		return url;
